
3.3 Go程序的基本结构
============================

hello world
>>>>>>>>>>>>>>>>>

HelloWorld.go:

.. code-block:: go

	package main

	import "fmt"  // Package implementing formatted I/O.

	func main() {
		fmt.Println("hello, world")
	}

..

透过上述程序，衍生出下述几个重要概念

* 包
* 函数
* 注释
* Go程序的基本组成结构


包的基本概念、导入及可见性
>>>>>>>>>>>>>>>>>>>>>>>>>>>>>

包是结构化或聚合化程序代码的一种方式，每一个程序均涉及包（ *pkg*）的概念，它可以从当前程序所在包或者其他包中进行导入操作。
在Go语言中，相较于其他语言，其包就类似于类库或者命名空间的概念，每一个go文件都有且仅属于一个包，一个包下由众多 * .go *  文件组成，
此外，你还必须在源文件的第一行显式指明这个文件隶属于哪一个包。
对于一个Go应用程序而言，其工程下需要有一个可独立执行的程序（也就是 *package main*）。

一个应用程序可以包含不同的包，如果应用程序只用到了 *package main* 包， 并且造成单个源文件代码量庞大，也可以试试将代码适当拆分到多个 packe main 包下的其他文件中。
所以我们可以换一个角度看待包，即包在Go中，是一个大范围的命名空间。


标准库 

在 Go 的安装文件里包含了一些可以直接使用的包，即标准库。
在 Windows 下，标准库的位 置在 Go 根目录下的子目录 pkg\windows_386 中；
在 Linux 下，标准库在 Go 根目录下的子目 录 pkg\linux_amd64 中（如果是安装的是 32 位，则在 linux_386 目录中）。
一般情况下， 标准包会存放在 $GOROOT/pkg/$GOOS_$GOARCH/ 目录下。

如果想要构建一个程序，则包和包内的文件都必须以正确的顺序进行编译。包的依赖关系决 定了其构建顺序。
Go 程序的基本结构和要素 属于同一个包的源文件必须全部被一起编译，一个包即是编译时的一个单元，因此根据惯 例，每个目录都只包含一个包。 
如果对一个包进行更改或重新编译，所有引用了这个包的客户端程序都必须全部重新编译。 
Go 中的包模型采用了显式依赖关系的机制来达到快速编译的目的，编译器会从后缀名为 .o 的对象文件（需要且只需要这个文件）中提取传递依赖类型的信息。 

如何优雅地导入多个包呢?(当你导入多个包时，导入的顺序会按照字母排序哦)

.. code-block:: go

	// 方式一
	import fout "fmt"
	import "os"
	
	// 方式二
	import fout "fmt"; import "os"

	// 方式三(推荐)
	import (
		fout "fmt"
		"os"
	)
	
	// 方式四
	import (fout "fmt"; "os")
..

可见性

在包中如果以大写字母开头的命名（包括常量、变量、类型、函数名、结构字段等等），即为public级别，这些命名能够被外部包所导入访问；
反之，若命名为小写字母开头，即为private级别，仅包内部可见。

函数
>>>>>>>>>>>>>>

简单定义一个函数格式

.. code-block:: go

	func funcName([params_list])[ret_types] {
		// do something
	}
	
..

函数定义:

1. func:函数是以func为关键字
2. funcName：函数名称，函数名和参数列表一起构成了函数签名
3. params_list list：参数列表，支持传递到函数内部的参数，可以是一个参数，也可以是多个参数(可变参数，用 name ...type来标识),这个值被称为实际参数。参数列表指定的是参数类型、顺序、及参数个数。参数是可选的，也就是说函数也可以不包含参数
4. ret_types：返回类型，函数返回一列值。ret_types 是该列值的数据类型。有些功能不需要返回值，这种情况下 ret_types 不是必须的。
5. do something：函数定义的代码集合。
