15.3 浮点数精度问题及现象解释
==============================

这里我们需要了解到的是计算机是二进制的世界，
任何数字都是以二进制形式存储的，例如：4是10，
44是10001，前述情况是整数的存储。但是对于小数而言，
例子如下：

.. code-block::
	
	   0.11
	*     2
	=  0.22   取得整数部分0
	*     2
	=  0.44   0
	*     2
	=  0.88   0
	*     2
	=  1.76   1
	*     2
	=  1.52   1
	*     2   
	=  1.04   1
	*     2
	=  0.08   0
	...       (乘2取整法)
	
	最终0.11的二进制表示为 0.0001110000101000，也就是2^-4 + 2^-5 + 2^-6 + 2^-11 + 2^-13 = 0.1099853515625
	如果我们限定该数的精度，就出现了精度误差
	
..

IEEE 754规定，有四种精度的浮点数：单精确度（32位）、双精确度（64位）、延伸单精确度（43比特以上，很少使用）与延伸双精确度（79比特以上，通常以80位实现）。
其运算规则如下::

	V = (-1)^s × 2^E × M
	（1）(-1)^s表示符号位，当s=0，V为正数；当s=1，V为负数。
	（2）2^E表示指数位。
	（3）M表示有效数字，大于等于1，小于2。

对于32位的浮点数，其最高1位为符号位S，其后8位为指数位E，剩余23位为有效数字位M。
对于64位的浮点数，其最高1位为符号位S，其后11位为指数位E，剩余52位为有效数字位M。

1. 对于第一段Sign，就是符号位，0代表正，1代表负。

2. 第二段Exponent指数位，实际也是有正负的，但是没有单独的符号位，在计算机的世界里，进位都是二进制的，指数表示的也是2的N次幂，8位指数表达的范围是0到255，而对应的实际的指数是－127到128。也就是说实际的指数等于指数位表示的数值减127。这里特殊说明，－127和＋128这两个指数数值在IEEE当中是保留的用作多种用途的，关于指数位与实际的指数之差叫做移码，移码的值

	========= =============== ====== ==================
	精度      M(阶/指数数位)  移码   二进制表示
	--------- --------------- ------ ------------------
	单精度    8               127    0111 1111
	双精度    11              1023   011 1111 1111
	长双精度  15              16383  011 1111 1111 1111
	========= =============== ====== ==================


3. 第三段Mantissa基数位（也叫有效数字），只代表了二进制的小数点后的部分，小数点前的那位被省略了，当指数位全部为0时省略的是0否则省略的是1。

::
	
	例如我们以数值5.2为例，可得到二进制形式为101.00110011001100110011，接下来进行规格化处理
	1.保证小数点前只有一位（规格化）：
		101.00110011001100110011 = 1.0100110011001100110011 * 2^(-2)
	2.符号位：
		因为5.2为正数，填充0；
	2.指数部分（E）:
		因为127作为偏移量，则指数部分的最终偏移量为127+2=129即10000001，所以E=10000001；
	3.基数（尾数）部分：
		除了简单的填入外，需要特别解释的地方是1.010011....中的整数部分1在填充时被舍去了。因为规格化后的数值整部部分总是为1。
		那大家可能有疑问了，省略整数部分后岂不是1.010011..和0.010011..就混淆了么？
		其实并不会，如果你仔细看下后者：会发现他并不是一个规格化的二进制，可以改写成1.0011 * 2^-2。
		所以省略小数点前的一个bit不会造成任何两个浮点数的混淆；
	4.得到填充后的结果为：
		0 10000001 0100110011001100110011
	5.验证：
		


